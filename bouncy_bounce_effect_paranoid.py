
# Blender 4.4 - "Bouncy Bounce Effect" Geometry Nodes Script
# Generated by the Gemini CLI (Paranoid Edition)

# === Blender GN Safety Header (from analyzed best practices) =================
import bpy
import math

def socket(iface, *, name, in_out, socket_type, desc=""):
    """Safely create a new socket on the node group interface."""
    return iface.new_socket(name=name, in_out=in_out, socket_type=socket_type, description=desc)

def configure_float_curve(curve_node, settings):
    """Sets all properties for a Float Curve node, including clipping and points."""
    if not curve_node or curve_node.bl_idname != 'ShaderNodeFloatCurve':
        return
    
    mapping = curve_node.mapping
    mapping.clip_min_x = settings.get("clip_min_x", 0.0)
    mapping.clip_max_x = settings.get("clip_max_x", 1.0)
    mapping.clip_min_y = settings.get("clip_min_y", 0.0)
    mapping.clip_max_y = settings.get("clip_max_y", 1.0)

    points_data = settings.get("float_curve_points", [])
    curve = mapping.curves[0]
    
    while len(curve.points) > len(points_data):
        curve.points.remove(curve.points[-1])
    while len(curve.points) < len(points_data):
        curve.points.new(0, 0)
        
    for i, point_data in enumerate(points_data):
        point = curve.points[i]
        point.location = point_data["location"]
        point.handle_type = point_data["handle_type"]

def new_node(nodes, bl_idname, *, location=(0,0)):
    """Create a new node."""
    if not hasattr(bpy.types, bl_idname):
        raise RuntimeError(f"Unsupported node type: {bl_idname}.")
    n = nodes.new(bl_idname)
    n.location = location
    return n

def new_gn_group(name="GN Group"):
    """Create a new, empty Geometry Node group."""
    ng = bpy.data.node_groups.new(name, 'GeometryNodeTree')
    for n in list(ng.nodes): ng.nodes.remove(n)
    return ng

def attach_group_modifier(obj, ng, name="GN Modifier"):
    """Attach a node group to an object's GN modifier."""
    mod = next((m for m in obj.modifiers if m.type == 'NODES'), None)
    if mod is None: mod = obj.modifiers.new(name=name, type='NODES')
    mod.node_group = ng
    return mod

def ensure_active_object():
    """Ensures there is an active object, creating a plane if necessary."""
    if bpy.context.active_object is None:
        bpy.ops.mesh.primitive_plane_add()
    return bpy.context.active_object
# === End Safety Header =====================================================

def build_bouncy_bounce_tree(ng):
    """Constructs the node tree for the Bouncy Bounce effect."""
    nodes, links, iface = ng.nodes, ng.links, ng.interface

    # ---- Interface Definition ----
    socket(iface, name="Geometry", in_out='INPUT', socket_type='NodeSocketGeometry')
    socket(iface, name="Geometry", in_out='OUTPUT', socket_type='NodeSocketGeometry')
    socket(iface, name="Mesh", in_out='OUTPUT', socket_type='NodeSocketGeometry')

    # ---- Node Graph Construction ----
    
    n_group_output = new_node(nodes, 'NodeGroupOutput', location=(1878.9, 169.9))
    
    n_uv_sphere = new_node(nodes, 'GeometryNodeMeshUVSphere', location=(-353.4, 135.0))
    n_uv_sphere.inputs[0].default_value = 32
    n_uv_sphere.inputs[1].default_value = 16
    n_uv_sphere.inputs[2].default_value = 0.5
    
    n_set_shade_smooth = new_node(nodes, 'GeometryNodeSetShadeSmooth', location=(-119.8, 116.0))
    
    n_set_material = new_node(nodes, 'GeometryNodeSetMaterial', location=(71.9, 99.1))
    
    n_geometry_to_instance = new_node(nodes, 'GeometryNodeGeometryToInstance', location=(1008.9, 114.8))
    
    n_bounding_box_001 = new_node(nodes, 'GeometryNodeBoundBox', location=(299.9, 24.8))
    
    n_set_position = new_node(nodes, 'GeometryNodeSetPosition', location=(781.6, 129.4))
    
    n_vector_math = new_node(nodes, 'ShaderNodeVectorMath', location=(520.9, 49.5))
    n_vector_math.operation = 'MULTIPLY'
    n_vector_math.inputs[1].default_value = [0.0, 0.0, -1.0]
    
    n_set_position_001 = new_node(nodes, 'GeometryNodeSetPosition', location=(1648.5, 208.1))
    
    n_scene_time = new_node(nodes, 'GeometryNodeInputSceneTime', location=(-474.3, -538.4))
    
    n_math = new_node(nodes, 'ShaderNodeMath', location=(-296.8, -509.8))
    n_math.operation = 'DIVIDE'
    n_math.use_clamp = False
    n_math.inputs[1].default_value = 50.0
    
    n_vector_math_001 = new_node(nodes, 'ShaderNodeVectorMath', location=(1321.8, -204.9))
    n_vector_math_001.operation = 'SCALE'
    n_vector_math_001.inputs[0].default_value = [0.0, 0.0, 2.0]
    
    n_math_001 = new_node(nodes, 'ShaderNodeMath', location=(-88.6, -495.3))
    n_math_001.operation = 'WRAP'
    n_math_001.use_clamp = False
    n_math_001.inputs[1].default_value = 0.0 # Min
    n_math_001.inputs[2].default_value = 1.0 # Max
    
    n_float_curve = new_node(nodes, 'ShaderNodeFloatCurve', location=(218.6, -532.7))
    configure_float_curve(n_float_curve, {'clip_min_x': 0.0, 'clip_max_x': 1.0, 'clip_min_y': 0.0, 'clip_max_y': 1.0, 'float_curve_points': [{'location': [0.0, 0.0], 'handle_type': 'AUTO'}, {'location': [0.2409, 0.1062], 'handle_type': 'AUTO'}, {'location': [0.6045, 0.9812], 'handle_type': 'AUTO'}, {'location': [0.7182, 0.9813], 'handle_type': 'AUTO'}, {'location': [0.8773, 0.5312], 'handle_type': 'VECTOR'}, {'location': [0.9773, 0.0], 'handle_type': 'AUTO'}]})
    
    n_scale_instances = new_node(nodes, 'GeometryNodeScaleInstances', location=(1289.8, 185.7))
    
    n_combine_xyz = new_node(nodes, 'ShaderNodeCombineXYZ', location=(1026.7, -119.4))
    
    n_math_002 = new_node(nodes, 'ShaderNodeMath', location=(800.0, -91.6))
    n_math_002.operation = 'DIVIDE'
    n_math_002.use_clamp = False
    n_math_002.inputs[0].default_value = 1.0 # Dividend
    
    n_map_range = new_node(nodes, 'ShaderNodeMapRange', location=(623.3, -155.2))
    n_map_range.data_type = 'FLOAT'
    n_map_range.inputs[1].default_value = -1.0
    n_map_range.inputs[2].default_value = 1.0
    n_map_range.inputs[3].default_value = 0.2
    n_map_range.inputs[4].default_value = 1.8
    
    n_float_curve_001 = new_node(nodes, 'ShaderNodeFloatCurve', location=(263.9, -155.9))
    configure_float_curve(n_float_curve_001, {'clip_min_x': 0.0, 'clip_max_x': 1.0, 'clip_min_y': -1.0, 'clip_max_y': 1.0, 'float_curve_points': [{'location': [0.0, 0.0125], 'handle_type': 'AUTO'}, {'location': [0.1091, -0.45], 'handle_type': 'AUTO'}, {'location': [0.3818, 0.75], 'handle_type': 'AUTO'}, {'location': [0.6227, -0.2375], 'handle_type': 'AUTO'}, {'location': [0.8318, 0.15], 'handle_type': 'AUTO'}, {'location': [1.0, 0.0125], 'handle_type': 'VECTOR'}]})

    # ---- Link Nodes ----
    links.new(n_uv_sphere.outputs["Mesh"], n_set_shade_smooth.inputs["Geometry"])
    links.new(n_set_shade_smooth.outputs["Geometry"], n_set_material.inputs["Geometry"])
    links.new(n_set_material.outputs["Geometry"], n_bounding_box_001.inputs["Geometry"])
    links.new(n_set_position.outputs["Geometry"], n_geometry_to_instance.inputs["Geometry"])
    links.new(n_set_material.outputs["Geometry"], n_set_position.inputs["Geometry"])
    links.new(n_vector_math.outputs["Vector"], n_set_position.inputs["Offset"])
    links.new(n_bounding_box_001.outputs["Min"], n_vector_math.inputs["Vector"])
    links.new(n_scale_instances.outputs["Instances"], n_set_position_001.inputs["Geometry"])
    links.new(n_set_position_001.outputs["Geometry"], n_group_output.inputs["Geometry"])
    links.new(n_scene_time.outputs["Frame"], n_math.inputs["Value"])
    links.new(n_vector_math_001.outputs["Vector"], n_set_position_001.inputs["Offset"])
    links.new(n_math.outputs["Value"], n_math_001.inputs["Value"])
    links.new(n_math_001.outputs["Value"], n_float_curve.inputs["Value"])
    links.new(n_float_curve.outputs["Value"], n_vector_math_001.inputs["Scale"])
    links.new(n_geometry_to_instance.outputs["Instances"], n_scale_instances.inputs["Instances"])
    links.new(n_combine_xyz.outputs["Vector"], n_scale_instances.inputs["Scale"])
    links.new(n_math_002.outputs["Value"], n_combine_xyz.inputs["X"])
    links.new(n_math_002.outputs["Value"], n_combine_xyz.inputs["Y"])
    links.new(n_map_range.outputs["Result"], n_math_002.inputs[1]) # Link to Divisor
    links.new(n_map_range.outputs["Result"], n_combine_xyz.inputs["Z"])
    links.new(n_float_curve_001.outputs["Value"], n_map_range.inputs["Value"])
    links.new(n_math_001.outputs["Value"], n_float_curve_001.inputs["Value"])

def setup_and_run():
    """Primary function to set up the scene and run the node tree creation."""
    print("--- Starting Bouncy Bounce Effect Script (Paranoid) ---")
    if bpy.context.scene.objects:
        bpy.ops.object.select_all(action='SELECT')
        bpy.ops.object.delete(use_global=False)
    obj = ensure_active_object()
    obj.name = "BouncyBounceObject"
    ng = new_gn_group("BouncyBounceEffect")
    build_bouncy_bounce_tree(ng)
    mod = attach_group_modifier(obj, ng, "BouncyBounceModifier")
    print(f"Successfully created and assigned '{ng.name}' to '{obj.name}'.")
    print("--- Bouncy Bounce Effect Script Finished ---")

if __name__ == "__main__":
    setup_and_run()
