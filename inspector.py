# inspector.py (Paranoid Edition) - DO NOT EDIT: This is a temporary script generated by the Gemini CLI.
import bpy
import json
import sys
from mathutils import Vector, Color, Euler

def get_serializable_value(value):
    """Converts Blender property types to JSON-serializable types with paranoid accuracy."""
    if isinstance(value, (Vector, Color, Euler)):
        return list(value)
    if "bpy_prop_array" in str(type(value)):
        return [v for v in value]
    if isinstance(value, (str, int, float, bool, type(None))):
        return value
    if isinstance(value, bpy.types.Object): return value.name if value else None
    if isinstance(value, bpy.types.Collection): return value.name if value else None
    if isinstance(value, bpy.types.Material): return value.name if value else None
    return repr(value)

def inspect_node_tree():
    """
    Inspects the geometry node tree and prints its structure as a JSON object
    with the highest possible, paranoid fidelity.
    """
    if not bpy.context.active_object:
        print(json.dumps({"error": "No active object found."}), file=sys.stderr)
        return
    
    obj = bpy.context.active_object
    gn_modifier = next((m for m in obj.modifiers if m.type == 'NODES'), None)

    if not gn_modifier or not gn_modifier.node_group:
        print(json.dumps({"error": "No Geometry Nodes modifier or node group found."}), file=sys.stderr)
        return

    node_tree = gn_modifier.node_group
    nodes_data = []
    links_data = []
    interface_data = {"inputs": [], "outputs": []}

    for item in node_tree.interface.items_tree:
        socket_info = { "name": item.name, "socket_type": item.socket_type }
        if item.in_out == 'INPUT':
            interface_data["inputs"].append(socket_info)
        else:
            interface_data["outputs"].append(socket_info)

    for node in node_tree.nodes:
        node_info = {
            "name": node.name,
            "bl_idname": node.bl_idname,
            "label": node.label,
            "location": [node.location.x, node.location.y],
            "settings": {},
            "inputs": {}
        }

        common_settings = ['operation', 'mode', 'clamp', 'data_type', 'use_clamp']
        for setting in common_settings:
            if hasattr(node, setting):
                node_info["settings"][setting] = getattr(node, setting)
        
        if node.bl_idname == 'ShaderNodeFloatCurve':
            mapping = node.mapping
            node_info["settings"]["clip_min_x"] = mapping.clip_min_x
            node_info["settings"]["clip_max_x"] = mapping.clip_max_x
            node_info["settings"]["clip_min_y"] = mapping.clip_min_y
            node_info["settings"]["clip_max_y"] = mapping.clip_max_y
            
            points_data = []
            for point in mapping.curves[0].points:
                points_data.append({
                    "location": [point.location.x, point.location.y],
                    "handle_type": point.handle_type
                })
            node_info["settings"]["float_curve_points"] = points_data

        # Paranoid input capture: Get the default_value for EVERY unconnected socket.
        for i, socket in enumerate(node.inputs):
            if not socket.is_linked and socket.enabled and hasattr(socket, 'default_value'):
                # Use index to avoid ambiguity with sockets that have the same name
                input_key = f"input_{i}"
                node_info["inputs"][input_key] = {
                    "name": socket.name,
                    "value": get_serializable_value(socket.default_value)
                }

        nodes_data.append(node_info)

    for link in node_tree.links:
        links_data.append({
            "from_node": link.from_node.name,
            "from_socket": link.from_socket.name,
            "to_node": link.to_node.name,
            "to_socket": link.to_socket.name,
        })

    result = { "tree_name": node_tree.name, "nodes": nodes_data, "links": links_data, "interface": interface_data }
    print(json.dumps(result, indent=2, separators=(',', ': ')))

if __name__ == "__main__":
    inspect_node_tree()